// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Bindings for `lame`.
///
/// Regenerate bindings with `dart run ffigen --config ffigen_lame.yaml`.
///
class LibLame {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
  _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  LibLame(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  LibLame.fromLookup(
    ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup,
  ) : _lookup = lookup;

  /// REQUIRED:
  /// initialize the encoder.  sets default for all encoder parameters,
  /// returns NULL if some malloc()'s failed
  /// otherwise returns pointer to structure needed for all future
  /// API calls.
  ffi.Pointer<lame_global_flags> lame_init() {
    return _lame_init();
  }

  late final _lame_initPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<lame_global_flags> Function()>>(
        'lame_init',
      );
  late final _lame_init =
      _lame_initPtr.asFunction<ffi.Pointer<lame_global_flags> Function()>();

  /// input stream description
  /// /
  /// /* number of samples.  default = 2^32-1
  int lame_set_num_samples(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_num_samples(arg0, arg1);
  }

  late final _lame_set_num_samplesPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.UnsignedLong)
    >
  >('lame_set_num_samples');
  late final _lame_set_num_samples =
      _lame_set_num_samplesPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_num_samples(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_num_samples(arg0);
  }

  late final _lame_get_num_samplesPtr = _lookup<
    ffi.NativeFunction<
      ffi.UnsignedLong Function(ffi.Pointer<lame_global_flags>)
    >
  >('lame_get_num_samples');
  late final _lame_get_num_samples =
      _lame_get_num_samplesPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// input sample rate in Hz.  default = 44100hz
  int lame_set_in_samplerate(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_in_samplerate(arg0, arg1);
  }

  late final _lame_set_in_sampleratePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_in_samplerate');
  late final _lame_set_in_samplerate =
      _lame_set_in_sampleratePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_in_samplerate(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_in_samplerate(arg0);
  }

  late final _lame_get_in_sampleratePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_in_samplerate');
  late final _lame_get_in_samplerate =
      _lame_get_in_sampleratePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// number of channels in input stream. default=2
  int lame_set_num_channels(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_num_channels(arg0, arg1);
  }

  late final _lame_set_num_channelsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_num_channels');
  late final _lame_set_num_channels =
      _lame_set_num_channelsPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_num_channels(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_num_channels(arg0);
  }

  late final _lame_get_num_channelsPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_num_channels');
  late final _lame_get_num_channels =
      _lame_get_num_channelsPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// scale the input by this amount before encoding.  default=1
  /// (not used by decoding routines)
  int lame_set_scale(ffi.Pointer<lame_global_flags> arg0, double arg1) {
    return _lame_set_scale(arg0, arg1);
  }

  late final _lame_set_scalePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Float)
    >
  >('lame_set_scale');
  late final _lame_set_scale =
      _lame_set_scalePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, double)>();

  double lame_get_scale(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_scale(arg0);
  }

  late final _lame_get_scalePtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_scale');
  late final _lame_get_scale =
      _lame_get_scalePtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  /// scale the channel 0 (left) input by this amount before encoding.  default=1
  /// (not used by decoding routines)
  int lame_set_scale_left(ffi.Pointer<lame_global_flags> arg0, double arg1) {
    return _lame_set_scale_left(arg0, arg1);
  }

  late final _lame_set_scale_leftPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Float)
    >
  >('lame_set_scale_left');
  late final _lame_set_scale_left =
      _lame_set_scale_leftPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, double)>();

  double lame_get_scale_left(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_scale_left(arg0);
  }

  late final _lame_get_scale_leftPtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_scale_left');
  late final _lame_get_scale_left =
      _lame_get_scale_leftPtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  /// scale the channel 1 (right) input by this amount before encoding.  default=1
  /// (not used by decoding routines)
  int lame_set_scale_right(ffi.Pointer<lame_global_flags> arg0, double arg1) {
    return _lame_set_scale_right(arg0, arg1);
  }

  late final _lame_set_scale_rightPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Float)
    >
  >('lame_set_scale_right');
  late final _lame_set_scale_right =
      _lame_set_scale_rightPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, double)>();

  double lame_get_scale_right(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_scale_right(arg0);
  }

  late final _lame_get_scale_rightPtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_scale_right');
  late final _lame_get_scale_right =
      _lame_get_scale_rightPtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  /// output sample rate in Hz.  default = 0, which means LAME picks best value
  /// based on the amount of compression.  MPEG only allows:
  /// MPEG1    32, 44.1,   48khz
  /// MPEG2    16, 22.05,  24
  /// MPEG2.5   8, 11.025, 12
  /// (not used by decoding routines)
  int lame_set_out_samplerate(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_out_samplerate(arg0, arg1);
  }

  late final _lame_set_out_sampleratePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_out_samplerate');
  late final _lame_set_out_samplerate =
      _lame_set_out_sampleratePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_out_samplerate(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_out_samplerate(arg0);
  }

  late final _lame_get_out_sampleratePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_out_samplerate');
  late final _lame_get_out_samplerate =
      _lame_get_out_sampleratePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// general control parameters
  /// /
  /// /* 1=cause LAME to collect data for an MP3 frame analyzer. default=0
  int lame_set_analysis(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_analysis(arg0, arg1);
  }

  late final _lame_set_analysisPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_analysis');
  late final _lame_set_analysis =
      _lame_set_analysisPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_analysis(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_analysis(arg0);
  }

  late final _lame_get_analysisPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_analysis');
  late final _lame_get_analysis =
      _lame_get_analysisPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// 1 = write a Xing VBR header frame.
  /// default = 1
  /// this variable must have been added by a Hungarian notation Windows programmer :-)
  int lame_set_bWriteVbrTag(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_bWriteVbrTag(arg0, arg1);
  }

  late final _lame_set_bWriteVbrTagPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_bWriteVbrTag');
  late final _lame_set_bWriteVbrTag =
      _lame_set_bWriteVbrTagPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_bWriteVbrTag(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_bWriteVbrTag(arg0);
  }

  late final _lame_get_bWriteVbrTagPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_bWriteVbrTag');
  late final _lame_get_bWriteVbrTag =
      _lame_get_bWriteVbrTagPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// 1=decode only.  use lame/mpglib to convert mp3/ogg to wav.  default=0
  int lame_set_decode_only(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_decode_only(arg0, arg1);
  }

  late final _lame_set_decode_onlyPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_decode_only');
  late final _lame_set_decode_only =
      _lame_set_decode_onlyPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_decode_only(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_decode_only(arg0);
  }

  late final _lame_get_decode_onlyPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_decode_only');
  late final _lame_get_decode_only =
      _lame_get_decode_onlyPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// internal algorithm selection.  True quality is determined by the bitrate
  /// but this variable will effect quality by selecting expensive or cheap algorithms.
  /// quality=0..9.  0=best (very slow).  9=worst.
  /// recommended:  2     near-best quality, not too slow
  /// 5     good quality, fast
  /// 7     ok quality, really fast
  int lame_set_quality(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_quality(arg0, arg1);
  }

  late final _lame_set_qualityPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_quality');
  late final _lame_set_quality =
      _lame_set_qualityPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_quality(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_quality(arg0);
  }

  late final _lame_get_qualityPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_quality');
  late final _lame_get_quality =
      _lame_get_qualityPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// mode = 0,1,2,3 = stereo, jstereo, dual channel (not supported), mono
  /// default: lame picks based on compression ration and input channels
  int lame_set_mode(ffi.Pointer<lame_global_flags> arg0, MPEG_mode_e arg1) {
    return _lame_set_mode(arg0, arg1.value);
  }

  late final _lame_set_modePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.UnsignedInt)
    >
  >('lame_set_mode');
  late final _lame_set_mode =
      _lame_set_modePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  MPEG_mode_e lame_get_mode(ffi.Pointer<lame_global_flags> arg0) {
    return MPEG_mode_e.fromValue(_lame_get_mode(arg0));
  }

  late final _lame_get_modePtr = _lookup<
    ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_mode');
  late final _lame_get_mode =
      _lame_get_modePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// force_ms.  Force M/S for all frames.  For testing only.
  /// default = 0 (disabled)
  int lame_set_force_ms(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_force_ms(arg0, arg1);
  }

  late final _lame_set_force_msPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_force_ms');
  late final _lame_set_force_ms =
      _lame_set_force_msPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_force_ms(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_force_ms(arg0);
  }

  late final _lame_get_force_msPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_force_ms');
  late final _lame_get_force_ms =
      _lame_get_force_msPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// use free_format?  default = 0 (disabled)
  int lame_set_free_format(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_free_format(arg0, arg1);
  }

  late final _lame_set_free_formatPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_free_format');
  late final _lame_set_free_format =
      _lame_set_free_formatPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_free_format(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_free_format(arg0);
  }

  late final _lame_get_free_formatPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_free_format');
  late final _lame_get_free_format =
      _lame_get_free_formatPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// perform ReplayGain analysis?  default = 0 (disabled)
  int lame_set_findReplayGain(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_findReplayGain(arg0, arg1);
  }

  late final _lame_set_findReplayGainPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_findReplayGain');
  late final _lame_set_findReplayGain =
      _lame_set_findReplayGainPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_findReplayGain(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_findReplayGain(arg0);
  }

  late final _lame_get_findReplayGainPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_findReplayGain');
  late final _lame_get_findReplayGain =
      _lame_get_findReplayGainPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// decode on the fly. Search for the peak sample. If the ReplayGain
  /// analysis is enabled then perform the analysis on the decoded data
  /// stream. default = 0 (disabled)
  /// NOTE: if this option is set the build-in decoder should not be used
  int lame_set_decode_on_the_fly(
    ffi.Pointer<lame_global_flags> arg0,
    int arg1,
  ) {
    return _lame_set_decode_on_the_fly(arg0, arg1);
  }

  late final _lame_set_decode_on_the_flyPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_decode_on_the_fly');
  late final _lame_set_decode_on_the_fly =
      _lame_set_decode_on_the_flyPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_decode_on_the_fly(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_decode_on_the_fly(arg0);
  }

  late final _lame_get_decode_on_the_flyPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_decode_on_the_fly');
  late final _lame_get_decode_on_the_fly =
      _lame_get_decode_on_the_flyPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// counters for gapless encoding
  int lame_set_nogap_total(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_nogap_total(arg0, arg1);
  }

  late final _lame_set_nogap_totalPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_nogap_total');
  late final _lame_set_nogap_total =
      _lame_set_nogap_totalPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_nogap_total(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_nogap_total(arg0);
  }

  late final _lame_get_nogap_totalPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_nogap_total');
  late final _lame_get_nogap_total =
      _lame_get_nogap_totalPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  int lame_set_nogap_currentindex(
    ffi.Pointer<lame_global_flags> arg0,
    int arg1,
  ) {
    return _lame_set_nogap_currentindex(arg0, arg1);
  }

  late final _lame_set_nogap_currentindexPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_nogap_currentindex');
  late final _lame_set_nogap_currentindex =
      _lame_set_nogap_currentindexPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_nogap_currentindex(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_nogap_currentindex(arg0);
  }

  late final _lame_get_nogap_currentindexPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_nogap_currentindex');
  late final _lame_get_nogap_currentindex =
      _lame_get_nogap_currentindexPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// OPTIONAL:
  /// Set printf like error/debug/message reporting functions.
  /// The second argument has to be a pointer to a function which looks like
  /// void my_debugf(const char *format, va_list ap)
  /// {
  /// (void) vfprintf(stdout, format, ap);
  /// }
  /// If you use NULL as the value of the pointer in the set function, the
  /// lame buildin function will be used (prints to stderr).
  /// To quiet any output you have to replace the body of the example function
  /// with just "return;" and use it in the set function.
  int lame_set_errorf(
    ffi.Pointer<lame_global_flags> arg0,
    lame_report_function arg1,
  ) {
    return _lame_set_errorf(arg0, arg1);
  }

  late final _lame_set_errorfPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, lame_report_function)
    >
  >('lame_set_errorf');
  late final _lame_set_errorf =
      _lame_set_errorfPtr
          .asFunction<
            int Function(ffi.Pointer<lame_global_flags>, lame_report_function)
          >();

  int lame_set_debugf(
    ffi.Pointer<lame_global_flags> arg0,
    lame_report_function arg1,
  ) {
    return _lame_set_debugf(arg0, arg1);
  }

  late final _lame_set_debugfPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, lame_report_function)
    >
  >('lame_set_debugf');
  late final _lame_set_debugf =
      _lame_set_debugfPtr
          .asFunction<
            int Function(ffi.Pointer<lame_global_flags>, lame_report_function)
          >();

  int lame_set_msgf(
    ffi.Pointer<lame_global_flags> arg0,
    lame_report_function arg1,
  ) {
    return _lame_set_msgf(arg0, arg1);
  }

  late final _lame_set_msgfPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, lame_report_function)
    >
  >('lame_set_msgf');
  late final _lame_set_msgf =
      _lame_set_msgfPtr
          .asFunction<
            int Function(ffi.Pointer<lame_global_flags>, lame_report_function)
          >();

  /// set one of brate compression ratio.  default is compression ratio of 11.
  int lame_set_brate(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_brate(arg0, arg1);
  }

  late final _lame_set_bratePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_brate');
  late final _lame_set_brate =
      _lame_set_bratePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_brate(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_brate(arg0);
  }

  late final _lame_get_bratePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_brate');
  late final _lame_get_brate =
      _lame_get_bratePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  int lame_set_compression_ratio(
    ffi.Pointer<lame_global_flags> arg0,
    double arg1,
  ) {
    return _lame_set_compression_ratio(arg0, arg1);
  }

  late final _lame_set_compression_ratioPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Float)
    >
  >('lame_set_compression_ratio');
  late final _lame_set_compression_ratio =
      _lame_set_compression_ratioPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, double)>();

  double lame_get_compression_ratio(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_compression_ratio(arg0);
  }

  late final _lame_get_compression_ratioPtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_compression_ratio');
  late final _lame_get_compression_ratio =
      _lame_get_compression_ratioPtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  int lame_set_preset(ffi.Pointer<lame_global_flags> gfp, int arg1) {
    return _lame_set_preset(gfp, arg1);
  }

  late final _lame_set_presetPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_preset');
  late final _lame_set_preset =
      _lame_set_presetPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_set_asm_optimizations(
    ffi.Pointer<lame_global_flags> gfp,
    int arg1,
    int arg2,
  ) {
    return _lame_set_asm_optimizations(gfp, arg1, arg2);
  }

  late final _lame_set_asm_optimizationsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int, ffi.Int)
    >
  >('lame_set_asm_optimizations');
  late final _lame_set_asm_optimizations =
      _lame_set_asm_optimizationsPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int, int)>();

  /// frame params
  /// /
  /// /* mark as copyright.  default=0
  int lame_set_copyright(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_copyright(arg0, arg1);
  }

  late final _lame_set_copyrightPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_copyright');
  late final _lame_set_copyright =
      _lame_set_copyrightPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_copyright(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_copyright(arg0);
  }

  late final _lame_get_copyrightPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_copyright');
  late final _lame_get_copyright =
      _lame_get_copyrightPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// mark as original.  default=1
  int lame_set_original(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_original(arg0, arg1);
  }

  late final _lame_set_originalPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_original');
  late final _lame_set_original =
      _lame_set_originalPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_original(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_original(arg0);
  }

  late final _lame_get_originalPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_original');
  late final _lame_get_original =
      _lame_get_originalPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// error_protection.  Use 2 bytes from each frame for CRC checksum. default=0
  int lame_set_error_protection(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_error_protection(arg0, arg1);
  }

  late final _lame_set_error_protectionPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_error_protection');
  late final _lame_set_error_protection =
      _lame_set_error_protectionPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_error_protection(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_error_protection(arg0);
  }

  late final _lame_get_error_protectionPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_error_protection');
  late final _lame_get_error_protection =
      _lame_get_error_protectionPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// MP3 'private extension' bit  Meaningless.  default=0
  int lame_set_extension(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_extension(arg0, arg1);
  }

  late final _lame_set_extensionPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_extension');
  late final _lame_set_extension =
      _lame_set_extensionPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_extension(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_extension(arg0);
  }

  late final _lame_get_extensionPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_extension');
  late final _lame_get_extension =
      _lame_get_extensionPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// enforce strict ISO compliance.  default=0
  int lame_set_strict_ISO(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_strict_ISO(arg0, arg1);
  }

  late final _lame_set_strict_ISOPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_strict_ISO');
  late final _lame_set_strict_ISO =
      _lame_set_strict_ISOPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_strict_ISO(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_strict_ISO(arg0);
  }

  late final _lame_get_strict_ISOPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_strict_ISO');
  late final _lame_get_strict_ISO =
      _lame_get_strict_ISOPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// disable the bit reservoir. For testing only. default=0
  int lame_set_disable_reservoir(
    ffi.Pointer<lame_global_flags> arg0,
    int arg1,
  ) {
    return _lame_set_disable_reservoir(arg0, arg1);
  }

  late final _lame_set_disable_reservoirPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_disable_reservoir');
  late final _lame_set_disable_reservoir =
      _lame_set_disable_reservoirPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_disable_reservoir(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_disable_reservoir(arg0);
  }

  late final _lame_get_disable_reservoirPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_disable_reservoir');
  late final _lame_get_disable_reservoir =
      _lame_get_disable_reservoirPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// select a different "best quantization" function. default=0
  int lame_set_quant_comp(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_quant_comp(arg0, arg1);
  }

  late final _lame_set_quant_compPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_quant_comp');
  late final _lame_set_quant_comp =
      _lame_set_quant_compPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_quant_comp(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_quant_comp(arg0);
  }

  late final _lame_get_quant_compPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_quant_comp');
  late final _lame_get_quant_comp =
      _lame_get_quant_compPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  int lame_set_quant_comp_short(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_quant_comp_short(arg0, arg1);
  }

  late final _lame_set_quant_comp_shortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_quant_comp_short');
  late final _lame_set_quant_comp_short =
      _lame_set_quant_comp_shortPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_quant_comp_short(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_quant_comp_short(arg0);
  }

  late final _lame_get_quant_comp_shortPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_quant_comp_short');
  late final _lame_get_quant_comp_short =
      _lame_get_quant_comp_shortPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  int lame_set_experimentalX(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_experimentalX(arg0, arg1);
  }

  late final _lame_set_experimentalXPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_experimentalX');
  late final _lame_set_experimentalX =
      _lame_set_experimentalXPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_experimentalX(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_experimentalX(arg0);
  }

  late final _lame_get_experimentalXPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_experimentalX');
  late final _lame_get_experimentalX =
      _lame_get_experimentalXPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// another experimental option.  for testing only
  int lame_set_experimentalY(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_experimentalY(arg0, arg1);
  }

  late final _lame_set_experimentalYPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_experimentalY');
  late final _lame_set_experimentalY =
      _lame_set_experimentalYPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_experimentalY(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_experimentalY(arg0);
  }

  late final _lame_get_experimentalYPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_experimentalY');
  late final _lame_get_experimentalY =
      _lame_get_experimentalYPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// another experimental option.  for testing only
  int lame_set_experimentalZ(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_experimentalZ(arg0, arg1);
  }

  late final _lame_set_experimentalZPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_experimentalZ');
  late final _lame_set_experimentalZ =
      _lame_set_experimentalZPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_experimentalZ(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_experimentalZ(arg0);
  }

  late final _lame_get_experimentalZPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_experimentalZ');
  late final _lame_get_experimentalZ =
      _lame_get_experimentalZPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// Naoki's psycho acoustic model.  default=0
  int lame_set_exp_nspsytune(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_exp_nspsytune(arg0, arg1);
  }

  late final _lame_set_exp_nspsytunePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_exp_nspsytune');
  late final _lame_set_exp_nspsytune =
      _lame_set_exp_nspsytunePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_exp_nspsytune(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_exp_nspsytune(arg0);
  }

  late final _lame_get_exp_nspsytunePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_exp_nspsytune');
  late final _lame_get_exp_nspsytune =
      _lame_get_exp_nspsytunePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  void lame_set_msfix(ffi.Pointer<lame_global_flags> arg0, double arg1) {
    return _lame_set_msfix(arg0, arg1);
  }

  late final _lame_set_msfixPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<lame_global_flags>, ffi.Double)
    >
  >('lame_set_msfix');
  late final _lame_set_msfix =
      _lame_set_msfixPtr
          .asFunction<void Function(ffi.Pointer<lame_global_flags>, double)>();

  double lame_get_msfix(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_msfix(arg0);
  }

  late final _lame_get_msfixPtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_msfix');
  late final _lame_get_msfix =
      _lame_get_msfixPtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  /// VBR control
  /// /
  /// /* Types of VBR.  default = vbr_off = CBR
  int lame_set_VBR(ffi.Pointer<lame_global_flags> arg0, vbr_mode_e arg1) {
    return _lame_set_VBR(arg0, arg1.value);
  }

  late final _lame_set_VBRPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.UnsignedInt)
    >
  >('lame_set_VBR');
  late final _lame_set_VBR =
      _lame_set_VBRPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  vbr_mode_e lame_get_VBR(ffi.Pointer<lame_global_flags> arg0) {
    return vbr_mode_e.fromValue(_lame_get_VBR(arg0));
  }

  late final _lame_get_VBRPtr = _lookup<
    ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_VBR');
  late final _lame_get_VBR =
      _lame_get_VBRPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// VBR quality level.  0=highest  9=lowest
  int lame_set_VBR_q(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_VBR_q(arg0, arg1);
  }

  late final _lame_set_VBR_qPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_VBR_q');
  late final _lame_set_VBR_q =
      _lame_set_VBR_qPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_VBR_q(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_VBR_q(arg0);
  }

  late final _lame_get_VBR_qPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_VBR_q');
  late final _lame_get_VBR_q =
      _lame_get_VBR_qPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// VBR quality level.  0=highest  9=lowest, Range [0,...,10[
  int lame_set_VBR_quality(ffi.Pointer<lame_global_flags> arg0, double arg1) {
    return _lame_set_VBR_quality(arg0, arg1);
  }

  late final _lame_set_VBR_qualityPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Float)
    >
  >('lame_set_VBR_quality');
  late final _lame_set_VBR_quality =
      _lame_set_VBR_qualityPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, double)>();

  double lame_get_VBR_quality(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_VBR_quality(arg0);
  }

  late final _lame_get_VBR_qualityPtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_VBR_quality');
  late final _lame_get_VBR_quality =
      _lame_get_VBR_qualityPtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  /// Ignored except for VBR=vbr_abr (ABR mode)
  int lame_set_VBR_mean_bitrate_kbps(
    ffi.Pointer<lame_global_flags> arg0,
    int arg1,
  ) {
    return _lame_set_VBR_mean_bitrate_kbps(arg0, arg1);
  }

  late final _lame_set_VBR_mean_bitrate_kbpsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_VBR_mean_bitrate_kbps');
  late final _lame_set_VBR_mean_bitrate_kbps =
      _lame_set_VBR_mean_bitrate_kbpsPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_VBR_mean_bitrate_kbps(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_VBR_mean_bitrate_kbps(arg0);
  }

  late final _lame_get_VBR_mean_bitrate_kbpsPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_VBR_mean_bitrate_kbps');
  late final _lame_get_VBR_mean_bitrate_kbps =
      _lame_get_VBR_mean_bitrate_kbpsPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  int lame_set_VBR_min_bitrate_kbps(
    ffi.Pointer<lame_global_flags> arg0,
    int arg1,
  ) {
    return _lame_set_VBR_min_bitrate_kbps(arg0, arg1);
  }

  late final _lame_set_VBR_min_bitrate_kbpsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_VBR_min_bitrate_kbps');
  late final _lame_set_VBR_min_bitrate_kbps =
      _lame_set_VBR_min_bitrate_kbpsPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_VBR_min_bitrate_kbps(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_VBR_min_bitrate_kbps(arg0);
  }

  late final _lame_get_VBR_min_bitrate_kbpsPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_VBR_min_bitrate_kbps');
  late final _lame_get_VBR_min_bitrate_kbps =
      _lame_get_VBR_min_bitrate_kbpsPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  int lame_set_VBR_max_bitrate_kbps(
    ffi.Pointer<lame_global_flags> arg0,
    int arg1,
  ) {
    return _lame_set_VBR_max_bitrate_kbps(arg0, arg1);
  }

  late final _lame_set_VBR_max_bitrate_kbpsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_VBR_max_bitrate_kbps');
  late final _lame_set_VBR_max_bitrate_kbps =
      _lame_set_VBR_max_bitrate_kbpsPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_VBR_max_bitrate_kbps(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_VBR_max_bitrate_kbps(arg0);
  }

  late final _lame_get_VBR_max_bitrate_kbpsPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_VBR_max_bitrate_kbps');
  late final _lame_get_VBR_max_bitrate_kbps =
      _lame_get_VBR_max_bitrate_kbpsPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// 1=strictly enforce VBR_min_bitrate.  Normally it will be violated for
  /// analog silence
  int lame_set_VBR_hard_min(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_VBR_hard_min(arg0, arg1);
  }

  late final _lame_set_VBR_hard_minPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_VBR_hard_min');
  late final _lame_set_VBR_hard_min =
      _lame_set_VBR_hard_minPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_VBR_hard_min(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_VBR_hard_min(arg0);
  }

  late final _lame_get_VBR_hard_minPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_VBR_hard_min');
  late final _lame_get_VBR_hard_min =
      _lame_get_VBR_hard_minPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// Filtering control
  /// /
  /// /* freq in Hz to apply lowpass. Default = 0 = lame chooses.  -1 = disabled
  int lame_set_lowpassfreq(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_lowpassfreq(arg0, arg1);
  }

  late final _lame_set_lowpassfreqPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_lowpassfreq');
  late final _lame_set_lowpassfreq =
      _lame_set_lowpassfreqPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_lowpassfreq(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_lowpassfreq(arg0);
  }

  late final _lame_get_lowpassfreqPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_lowpassfreq');
  late final _lame_get_lowpassfreq =
      _lame_get_lowpassfreqPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// width of transition band, in Hz.  Default = one polyphase filter band
  int lame_set_lowpasswidth(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_lowpasswidth(arg0, arg1);
  }

  late final _lame_set_lowpasswidthPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_lowpasswidth');
  late final _lame_set_lowpasswidth =
      _lame_set_lowpasswidthPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_lowpasswidth(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_lowpasswidth(arg0);
  }

  late final _lame_get_lowpasswidthPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_lowpasswidth');
  late final _lame_get_lowpasswidth =
      _lame_get_lowpasswidthPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// freq in Hz to apply highpass. Default = 0 = lame chooses.  -1 = disabled
  int lame_set_highpassfreq(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_highpassfreq(arg0, arg1);
  }

  late final _lame_set_highpassfreqPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_highpassfreq');
  late final _lame_set_highpassfreq =
      _lame_set_highpassfreqPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_highpassfreq(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_highpassfreq(arg0);
  }

  late final _lame_get_highpassfreqPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_highpassfreq');
  late final _lame_get_highpassfreq =
      _lame_get_highpassfreqPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// width of transition band, in Hz.  Default = one polyphase filter band
  int lame_set_highpasswidth(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_highpasswidth(arg0, arg1);
  }

  late final _lame_set_highpasswidthPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_highpasswidth');
  late final _lame_set_highpasswidth =
      _lame_set_highpasswidthPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_highpasswidth(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_highpasswidth(arg0);
  }

  late final _lame_get_highpasswidthPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_highpasswidth');
  late final _lame_get_highpasswidth =
      _lame_get_highpasswidthPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// only use ATH for masking
  int lame_set_ATHonly(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_ATHonly(arg0, arg1);
  }

  late final _lame_set_ATHonlyPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_ATHonly');
  late final _lame_set_ATHonly =
      _lame_set_ATHonlyPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_ATHonly(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_ATHonly(arg0);
  }

  late final _lame_get_ATHonlyPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_ATHonly');
  late final _lame_get_ATHonly =
      _lame_get_ATHonlyPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// only use ATH for short blocks
  int lame_set_ATHshort(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_ATHshort(arg0, arg1);
  }

  late final _lame_set_ATHshortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_ATHshort');
  late final _lame_set_ATHshort =
      _lame_set_ATHshortPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_ATHshort(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_ATHshort(arg0);
  }

  late final _lame_get_ATHshortPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_ATHshort');
  late final _lame_get_ATHshort =
      _lame_get_ATHshortPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// disable ATH
  int lame_set_noATH(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_noATH(arg0, arg1);
  }

  late final _lame_set_noATHPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_noATH');
  late final _lame_set_noATH =
      _lame_set_noATHPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_noATH(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_noATH(arg0);
  }

  late final _lame_get_noATHPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_noATH');
  late final _lame_get_noATH =
      _lame_get_noATHPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// select ATH formula
  int lame_set_ATHtype(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_ATHtype(arg0, arg1);
  }

  late final _lame_set_ATHtypePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_ATHtype');
  late final _lame_set_ATHtype =
      _lame_set_ATHtypePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_ATHtype(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_ATHtype(arg0);
  }

  late final _lame_get_ATHtypePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_ATHtype');
  late final _lame_get_ATHtype =
      _lame_get_ATHtypePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// lower ATH by this many db
  int lame_set_ATHlower(ffi.Pointer<lame_global_flags> arg0, double arg1) {
    return _lame_set_ATHlower(arg0, arg1);
  }

  late final _lame_set_ATHlowerPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Float)
    >
  >('lame_set_ATHlower');
  late final _lame_set_ATHlower =
      _lame_set_ATHlowerPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, double)>();

  double lame_get_ATHlower(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_ATHlower(arg0);
  }

  late final _lame_get_ATHlowerPtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_ATHlower');
  late final _lame_get_ATHlower =
      _lame_get_ATHlowerPtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  /// select ATH adaptive adjustment type
  int lame_set_athaa_type(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_athaa_type(arg0, arg1);
  }

  late final _lame_set_athaa_typePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_athaa_type');
  late final _lame_set_athaa_type =
      _lame_set_athaa_typePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_athaa_type(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_athaa_type(arg0);
  }

  late final _lame_get_athaa_typePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_athaa_type');
  late final _lame_get_athaa_type =
      _lame_get_athaa_typePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// adjust (in dB) the point below which adaptive ATH level adjustment occurs
  int lame_set_athaa_sensitivity(
    ffi.Pointer<lame_global_flags> arg0,
    double arg1,
  ) {
    return _lame_set_athaa_sensitivity(arg0, arg1);
  }

  late final _lame_set_athaa_sensitivityPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Float)
    >
  >('lame_set_athaa_sensitivity');
  late final _lame_set_athaa_sensitivity =
      _lame_set_athaa_sensitivityPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, double)>();

  double lame_get_athaa_sensitivity(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_athaa_sensitivity(arg0);
  }

  late final _lame_get_athaa_sensitivityPtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_athaa_sensitivity');
  late final _lame_get_athaa_sensitivity =
      _lame_get_athaa_sensitivityPtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  /// allow blocktypes to differ between channels?
  /// default: 0 for jstereo, 1 for stereo
  int lame_set_allow_diff_short(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_allow_diff_short(arg0, arg1);
  }

  late final _lame_set_allow_diff_shortPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_allow_diff_short');
  late final _lame_set_allow_diff_short =
      _lame_set_allow_diff_shortPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_allow_diff_short(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_allow_diff_short(arg0);
  }

  late final _lame_get_allow_diff_shortPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_allow_diff_short');
  late final _lame_get_allow_diff_short =
      _lame_get_allow_diff_shortPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// use temporal masking effect (default = 1)
  int lame_set_useTemporal(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_useTemporal(arg0, arg1);
  }

  late final _lame_set_useTemporalPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_useTemporal');
  late final _lame_set_useTemporal =
      _lame_set_useTemporalPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_useTemporal(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_useTemporal(arg0);
  }

  late final _lame_get_useTemporalPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_useTemporal');
  late final _lame_get_useTemporal =
      _lame_get_useTemporalPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// use temporal masking effect (default = 1)
  int lame_set_interChRatio(ffi.Pointer<lame_global_flags> arg0, double arg1) {
    return _lame_set_interChRatio(arg0, arg1);
  }

  late final _lame_set_interChRatioPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Float)
    >
  >('lame_set_interChRatio');
  late final _lame_set_interChRatio =
      _lame_set_interChRatioPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, double)>();

  double lame_get_interChRatio(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_interChRatio(arg0);
  }

  late final _lame_get_interChRatioPtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_interChRatio');
  late final _lame_get_interChRatio =
      _lame_get_interChRatioPtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  /// disable short blocks
  int lame_set_no_short_blocks(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_no_short_blocks(arg0, arg1);
  }

  late final _lame_set_no_short_blocksPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_no_short_blocks');
  late final _lame_set_no_short_blocks =
      _lame_set_no_short_blocksPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_no_short_blocks(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_no_short_blocks(arg0);
  }

  late final _lame_get_no_short_blocksPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_no_short_blocks');
  late final _lame_get_no_short_blocks =
      _lame_get_no_short_blocksPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// force short blocks
  int lame_set_force_short_blocks(
    ffi.Pointer<lame_global_flags> arg0,
    int arg1,
  ) {
    return _lame_set_force_short_blocks(arg0, arg1);
  }

  late final _lame_set_force_short_blocksPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_force_short_blocks');
  late final _lame_set_force_short_blocks =
      _lame_set_force_short_blocksPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_force_short_blocks(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_force_short_blocks(arg0);
  }

  late final _lame_get_force_short_blocksPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_force_short_blocks');
  late final _lame_get_force_short_blocks =
      _lame_get_force_short_blocksPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// Input PCM is emphased PCM (for instance from one of the rarely
  /// emphased CDs), it is STRONGLY not recommended to use this, because
  /// psycho does not take it into account, and last but not least many decoders
  /// ignore these bits
  int lame_set_emphasis(ffi.Pointer<lame_global_flags> arg0, int arg1) {
    return _lame_set_emphasis(arg0, arg1);
  }

  late final _lame_set_emphasisPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_emphasis');
  late final _lame_set_emphasis =
      _lame_set_emphasisPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_emphasis(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_emphasis(arg0);
  }

  late final _lame_get_emphasisPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_emphasis');
  late final _lame_get_emphasis =
      _lame_get_emphasisPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// /
  /// /* internal variables, cannot be set...                                 */
  /// /* provided because they may be of use to calling application           */
  /// /************************************************************************/
  /// /* version  0=MPEG-2  1=MPEG-1  (2=MPEG-2.5)
  int lame_get_version(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_version(arg0);
  }

  late final _lame_get_versionPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_version');
  late final _lame_get_version =
      _lame_get_versionPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// encoder delay
  int lame_get_encoder_delay(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_encoder_delay(arg0);
  }

  late final _lame_get_encoder_delayPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_encoder_delay');
  late final _lame_get_encoder_delay =
      _lame_get_encoder_delayPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// padding appended to the input to make sure decoder can fully decode
  /// all input.  Note that this value can only be calculated during the
  /// call to lame_encoder_flush().  Before lame_encoder_flush() has
  /// been called, the value of encoder_padding = 0.
  int lame_get_encoder_padding(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_encoder_padding(arg0);
  }

  late final _lame_get_encoder_paddingPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_encoder_padding');
  late final _lame_get_encoder_padding =
      _lame_get_encoder_paddingPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// size of MPEG frame
  int lame_get_framesize(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_framesize(arg0);
  }

  late final _lame_get_framesizePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_framesize');
  late final _lame_get_framesize =
      _lame_get_framesizePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// number of PCM samples buffered, but not yet encoded to mp3 data.
  int lame_get_mf_samples_to_encode(ffi.Pointer<lame_global_flags> gfp) {
    return _lame_get_mf_samples_to_encode(gfp);
  }

  late final _lame_get_mf_samples_to_encodePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_mf_samples_to_encode');
  late final _lame_get_mf_samples_to_encode =
      _lame_get_mf_samples_to_encodePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// size (bytes) of mp3 data buffered, but not yet encoded.
  /// this is the number of bytes which would be output by a call to
  /// lame_encode_flush_nogap.  NOTE: lame_encode_flush() will return
  /// more bytes than this because it will encode the reamining buffered
  /// PCM samples before flushing the mp3 buffers.
  int lame_get_size_mp3buffer(ffi.Pointer<lame_global_flags> gfp) {
    return _lame_get_size_mp3buffer(gfp);
  }

  late final _lame_get_size_mp3bufferPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_size_mp3buffer');
  late final _lame_get_size_mp3buffer =
      _lame_get_size_mp3bufferPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// number of frames encoded so far
  int lame_get_frameNum(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_frameNum(arg0);
  }

  late final _lame_get_frameNumPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_frameNum');
  late final _lame_get_frameNum =
      _lame_get_frameNumPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// lame's estimate of the total number of frames to be encoded
  /// only valid if calling program set num_samples
  int lame_get_totalframes(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_totalframes(arg0);
  }

  late final _lame_get_totalframesPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_totalframes');
  late final _lame_get_totalframes =
      _lame_get_totalframesPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// RadioGain value. Multiplied by 10 and rounded to the nearest.
  int lame_get_RadioGain(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_RadioGain(arg0);
  }

  late final _lame_get_RadioGainPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_RadioGain');
  late final _lame_get_RadioGain =
      _lame_get_RadioGainPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// AudiophileGain value. Multipled by 10 and rounded to the nearest.
  int lame_get_AudiophileGain(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_AudiophileGain(arg0);
  }

  late final _lame_get_AudiophileGainPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_AudiophileGain');
  late final _lame_get_AudiophileGain =
      _lame_get_AudiophileGainPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// the peak sample
  double lame_get_PeakSample(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_PeakSample(arg0);
  }

  late final _lame_get_PeakSamplePtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_PeakSample');
  late final _lame_get_PeakSample =
      _lame_get_PeakSamplePtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  /// Gain change required for preventing clipping. The value is correct only if
  /// peak sample searching was enabled. If negative then the waveform
  /// already does not clip. The value is multiplied by 10 and rounded up.
  int lame_get_noclipGainChange(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_noclipGainChange(arg0);
  }

  late final _lame_get_noclipGainChangePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_noclipGainChange');
  late final _lame_get_noclipGainChange =
      _lame_get_noclipGainChangePtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// user-specified scale factor required for preventing clipping. Value is
  /// correct only if peak sample searching was enabled and no user-specified
  /// scaling was performed. If negative then either the waveform already does
  /// not clip or the value cannot be determined
  double lame_get_noclipScale(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_get_noclipScale(arg0);
  }

  late final _lame_get_noclipScalePtr = _lookup<
    ffi.NativeFunction<ffi.Float Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_noclipScale');
  late final _lame_get_noclipScale =
      _lame_get_noclipScalePtr
          .asFunction<double Function(ffi.Pointer<lame_global_flags>)>();

  /// returns the limit of PCM samples, which one can pass in an encode call
  /// under the constrain of a provided buffer of size buffer_size
  int lame_get_maximum_number_of_samples(lame_t gfp, int buffer_size) {
    return _lame_get_maximum_number_of_samples(gfp, buffer_size);
  }

  late final _lame_get_maximum_number_of_samplesPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(lame_t, ffi.Size)>>(
        'lame_get_maximum_number_of_samples',
      );
  late final _lame_get_maximum_number_of_samples =
      _lame_get_maximum_number_of_samplesPtr
          .asFunction<int Function(lame_t, int)>();

  /// REQUIRED:
  /// sets more internal configuration based on data provided above.
  /// returns -1 if something failed.
  int lame_init_params(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_init_params(arg0);
  }

  late final _lame_init_paramsPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_init_params');
  late final _lame_init_params =
      _lame_init_paramsPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// OPTIONAL:
  /// get the version number, in a string. of the form:
  /// "3.63 (beta)" or just "3.63".
  ffi.Pointer<ffi.Char> get_lame_version() {
    return _get_lame_version();
  }

  late final _get_lame_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'get_lame_version',
      );
  late final _get_lame_version =
      _get_lame_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> get_lame_short_version() {
    return _get_lame_short_version();
  }

  late final _get_lame_short_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'get_lame_short_version',
      );
  late final _get_lame_short_version =
      _get_lame_short_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> get_lame_very_short_version() {
    return _get_lame_very_short_version();
  }

  late final _get_lame_very_short_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'get_lame_very_short_version',
      );
  late final _get_lame_very_short_version =
      _get_lame_very_short_versionPtr
          .asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> get_psy_version() {
    return _get_psy_version();
  }

  late final _get_psy_versionPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'get_psy_version',
      );
  late final _get_psy_version =
      _get_psy_versionPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> get_lame_url() {
    return _get_lame_url();
  }

  late final _get_lame_urlPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'get_lame_url',
      );
  late final _get_lame_url =
      _get_lame_urlPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  ffi.Pointer<ffi.Char> get_lame_os_bitness() {
    return _get_lame_os_bitness();
  }

  late final _get_lame_os_bitnessPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
        'get_lame_os_bitness',
      );
  late final _get_lame_os_bitness =
      _get_lame_os_bitnessPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void get_lame_version_numerical(ffi.Pointer<lame_version_t> arg0) {
    return _get_lame_version_numerical(arg0);
  }

  late final _get_lame_version_numericalPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lame_version_t>)>
  >('get_lame_version_numerical');
  late final _get_lame_version_numerical =
      _get_lame_version_numericalPtr
          .asFunction<void Function(ffi.Pointer<lame_version_t>)>();

  /// OPTIONAL:
  /// print internal lame configuration to message handler
  void lame_print_config(ffi.Pointer<lame_global_flags> gfp) {
    return _lame_print_config(gfp);
  }

  late final _lame_print_configPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lame_global_flags>)>
  >('lame_print_config');
  late final _lame_print_config =
      _lame_print_configPtr
          .asFunction<void Function(ffi.Pointer<lame_global_flags>)>();

  void lame_print_internals(ffi.Pointer<lame_global_flags> gfp) {
    return _lame_print_internals(gfp);
  }

  late final _lame_print_internalsPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(ffi.Pointer<lame_global_flags>)>
  >('lame_print_internals');
  late final _lame_print_internals =
      _lame_print_internalsPtr
          .asFunction<void Function(ffi.Pointer<lame_global_flags>)>();

  /// input pcm data, output (maybe) mp3 frames.
  /// This routine handles all buffering, resampling and filtering for you.
  ///
  /// return code     number of bytes output in mp3buf. Can be 0
  /// -1:  mp3buf was too small
  /// -2:  malloc() problem
  /// -3:  lame_init_params() not called
  /// -4:  psycho acoustic problems
  ///
  /// The required mp3buf_size can be computed from num_samples,
  /// samplerate and encoding rate, but here is a worst case estimate:
  ///
  /// mp3buf_size in bytes = 1.25*num_samples + 7200
  ///
  /// I think a tighter bound could be:  (mt, March 2000)
  /// MPEG1:
  /// num_samples*(bitrate/8)/samplerate + 4*1152*(bitrate/8)/samplerate + 512
  /// MPEG2:
  /// num_samples*(bitrate/8)/samplerate + 4*576*(bitrate/8)/samplerate + 256
  ///
  /// but test first if you use that!
  ///
  /// set mp3buf_size = 0 and LAME will not check if mp3buf_size is
  /// large enough.
  ///
  /// NOTE:
  /// if gfp->num_channels=2, but gfp->mode = 3 (mono), the L & R channels
  /// will be averaged into the L channel before encoding only the L channel
  /// This will overwrite the data in buffer_l[] and buffer_r[].
  int lame_encode_buffer(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Short> buffer_l,
    ffi.Pointer<ffi.Short> buffer_r,
    int nsamples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer(
      gfp,
      buffer_l,
      buffer_r,
      nsamples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_bufferPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.Short>,
        ffi.Pointer<ffi.Short>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer');
  late final _lame_encode_buffer =
      _lame_encode_bufferPtr
          .asFunction<
            int Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.Short>,
              ffi.Pointer<ffi.Short>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// as above, but input has L & R channel data interleaved.
  /// NOTE:
  /// num_samples = number of samples in the L (or R)
  /// channel, not the total number of samples in pcm[]
  int lame_encode_buffer_interleaved(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Short> pcm,
    int num_samples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer_interleaved(
      gfp,
      pcm,
      num_samples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_buffer_interleavedPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.Short>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer_interleaved');
  late final _lame_encode_buffer_interleaved =
      _lame_encode_buffer_interleavedPtr
          .asFunction<
            int Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.Short>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// as lame_encode_buffer, but for 'float's.
  /// !! NOTE: !! data must still be scaled to be in the same range as
  /// short int, +/- 32768
  int lame_encode_buffer_float(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Float> pcm_l,
    ffi.Pointer<ffi.Float> pcm_r,
    int nsamples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer_float(
      gfp,
      pcm_l,
      pcm_r,
      nsamples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_buffer_floatPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer_float');
  late final _lame_encode_buffer_float =
      _lame_encode_buffer_floatPtr
          .asFunction<
            int Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// as lame_encode_buffer, but for 'float's.
  /// !! NOTE: !! data must be scaled to +/- 1 full scale
  int lame_encode_buffer_ieee_float(
    lame_t gfp,
    ffi.Pointer<ffi.Float> pcm_l,
    ffi.Pointer<ffi.Float> pcm_r,
    int nsamples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer_ieee_float(
      gfp,
      pcm_l,
      pcm_r,
      nsamples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_buffer_ieee_floatPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        lame_t,
        ffi.Pointer<ffi.Float>,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer_ieee_float');
  late final _lame_encode_buffer_ieee_float =
      _lame_encode_buffer_ieee_floatPtr
          .asFunction<
            int Function(
              lame_t,
              ffi.Pointer<ffi.Float>,
              ffi.Pointer<ffi.Float>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  int lame_encode_buffer_interleaved_ieee_float(
    lame_t gfp,
    ffi.Pointer<ffi.Float> pcm,
    int nsamples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer_interleaved_ieee_float(
      gfp,
      pcm,
      nsamples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_buffer_interleaved_ieee_floatPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        lame_t,
        ffi.Pointer<ffi.Float>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer_interleaved_ieee_float');
  late final _lame_encode_buffer_interleaved_ieee_float =
      _lame_encode_buffer_interleaved_ieee_floatPtr
          .asFunction<
            int Function(
              lame_t,
              ffi.Pointer<ffi.Float>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// as lame_encode_buffer, but for 'double's.
  /// !! NOTE: !! data must be scaled to +/- 1 full scale
  int lame_encode_buffer_ieee_double(
    lame_t gfp,
    ffi.Pointer<ffi.Double> pcm_l,
    ffi.Pointer<ffi.Double> pcm_r,
    int nsamples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer_ieee_double(
      gfp,
      pcm_l,
      pcm_r,
      nsamples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_buffer_ieee_doublePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        lame_t,
        ffi.Pointer<ffi.Double>,
        ffi.Pointer<ffi.Double>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer_ieee_double');
  late final _lame_encode_buffer_ieee_double =
      _lame_encode_buffer_ieee_doublePtr
          .asFunction<
            int Function(
              lame_t,
              ffi.Pointer<ffi.Double>,
              ffi.Pointer<ffi.Double>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  int lame_encode_buffer_interleaved_ieee_double(
    lame_t gfp,
    ffi.Pointer<ffi.Double> pcm,
    int nsamples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer_interleaved_ieee_double(
      gfp,
      pcm,
      nsamples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_buffer_interleaved_ieee_doublePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        lame_t,
        ffi.Pointer<ffi.Double>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer_interleaved_ieee_double');
  late final _lame_encode_buffer_interleaved_ieee_double =
      _lame_encode_buffer_interleaved_ieee_doublePtr
          .asFunction<
            int Function(
              lame_t,
              ffi.Pointer<ffi.Double>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// as lame_encode_buffer, but for long's
  /// !! NOTE: !! data must still be scaled to be in the same range as
  /// short int, +/- 32768
  ///
  /// This scaling was a mistake (doesn't allow one to exploit full
  /// precision of type 'long'.  Use lame_encode_buffer_long2() instead.
  int lame_encode_buffer_long(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Long> buffer_l,
    ffi.Pointer<ffi.Long> buffer_r,
    int nsamples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer_long(
      gfp,
      buffer_l,
      buffer_r,
      nsamples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_buffer_longPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.Long>,
        ffi.Pointer<ffi.Long>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer_long');
  late final _lame_encode_buffer_long =
      _lame_encode_buffer_longPtr
          .asFunction<
            int Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.Long>,
              ffi.Pointer<ffi.Long>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// Same as lame_encode_buffer_long(), but with correct scaling.
  /// !! NOTE: !! data must still be scaled to be in the same range as
  /// type 'long'.   Data should be in the range:  +/- 2^(8*size(long)-1)
  int lame_encode_buffer_long2(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Long> buffer_l,
    ffi.Pointer<ffi.Long> buffer_r,
    int nsamples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer_long2(
      gfp,
      buffer_l,
      buffer_r,
      nsamples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_buffer_long2Ptr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.Long>,
        ffi.Pointer<ffi.Long>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer_long2');
  late final _lame_encode_buffer_long2 =
      _lame_encode_buffer_long2Ptr
          .asFunction<
            int Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.Long>,
              ffi.Pointer<ffi.Long>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// as lame_encode_buffer, but for int's
  /// !! NOTE: !! input should be scaled to the maximum range of 'int'
  /// If int is 4 bytes, then the values should range from
  /// +/- 2147483648.
  ///
  /// This routine does not (and cannot, without loosing precision) use
  /// the same scaling as the rest of the lame_encode_buffer() routines.
  int lame_encode_buffer_int(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Int> buffer_l,
    ffi.Pointer<ffi.Int> buffer_r,
    int nsamples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer_int(
      gfp,
      buffer_l,
      buffer_r,
      nsamples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_buffer_intPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer_int');
  late final _lame_encode_buffer_int =
      _lame_encode_buffer_intPtr
          .asFunction<
            int Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// as above, but for interleaved data.
  /// !! NOTE: !! data must still be scaled to be in the same range as
  /// type 'int32_t'.   Data should be in the range:  +/- 2^(8*size(int32_t)-1)
  /// NOTE:
  /// num_samples = number of samples in the L (or R)
  /// channel, not the total number of samples in pcm[]
  int lame_encode_buffer_interleaved_int(
    lame_t gfp,
    ffi.Pointer<ffi.Int> pcm,
    int nsamples,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int mp3buf_size,
  ) {
    return _lame_encode_buffer_interleaved_int(
      gfp,
      pcm,
      nsamples,
      mp3buf,
      mp3buf_size,
    );
  }

  late final _lame_encode_buffer_interleaved_intPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        lame_t,
        ffi.Pointer<ffi.Int>,
        ffi.Int,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_buffer_interleaved_int');
  late final _lame_encode_buffer_interleaved_int =
      _lame_encode_buffer_interleaved_intPtr
          .asFunction<
            int Function(
              lame_t,
              ffi.Pointer<ffi.Int>,
              int,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// REQUIRED:
  /// lame_encode_flush will flush the intenal PCM buffers, padding with
  /// 0's to make sure the final frame is complete, and then flush
  /// the internal MP3 buffers, and thus may return a
  /// final few mp3 frames.  'mp3buf' should be at least 7200 bytes long
  /// to hold all possible emitted data.
  ///
  /// will also write id3v1 tags (if any) into the bitstream
  ///
  /// return code = number of bytes output to mp3buf. Can be 0
  int lame_encode_flush(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int size,
  ) {
    return _lame_encode_flush(gfp, mp3buf, size);
  }

  late final _lame_encode_flushPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_flush');
  late final _lame_encode_flush =
      _lame_encode_flushPtr
          .asFunction<
            int Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// OPTIONAL:
  /// lame_encode_flush_nogap will flush the internal mp3 buffers and pad
  /// the last frame with ancillary data so it is a complete mp3 frame.
  ///
  /// 'mp3buf' should be at least 7200 bytes long
  /// to hold all possible emitted data.
  ///
  /// After a call to this routine, the outputed mp3 data is complete, but
  /// you may continue to encode new PCM samples and write future mp3 data
  /// to a different file.  The two mp3 files will play back with no gaps
  /// if they are concatenated together.
  ///
  /// This routine will NOT write id3v1 tags into the bitstream.
  ///
  /// return code = number of bytes output to mp3buf. Can be 0
  int lame_encode_flush_nogap(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int size,
  ) {
    return _lame_encode_flush_nogap(gfp, mp3buf, size);
  }

  late final _lame_encode_flush_nogapPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Int,
      )
    >
  >('lame_encode_flush_nogap');
  late final _lame_encode_flush_nogap =
      _lame_encode_flush_nogapPtr
          .asFunction<
            int Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// OPTIONAL:
  /// Normally, this is called by lame_init_params().  It writes id3v2 and
  /// Xing headers into the front of the bitstream, and sets frame counters
  /// and bitrate histogram data to 0.  You can also call this after
  /// lame_encode_flush_nogap().
  int lame_init_bitstream(ffi.Pointer<lame_global_flags> gfp) {
    return _lame_init_bitstream(gfp);
  }

  late final _lame_init_bitstreamPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_init_bitstream');
  late final _lame_init_bitstream =
      _lame_init_bitstreamPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// OPTIONAL:    some simple statistics
  /// a bitrate histogram to visualize the distribution of used frame sizes
  /// a stereo mode histogram to visualize the distribution of used stereo
  /// modes, useful in joint-stereo mode only
  /// 0: LR    left-right encoded
  /// 1: LR-I  left-right and intensity encoded (currently not supported)
  /// 2: MS    mid-side encoded
  /// 3: MS-I  mid-side and intensity encoded (currently not supported)
  ///
  /// attention: don't call them after lame_encode_finish
  /// suggested: lame_encode_flush -> lame_*_hist -> lame_close
  void lame_bitrate_hist(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Int> bitrate_count,
  ) {
    return _lame_bitrate_hist(gfp, bitrate_count);
  }

  late final _lame_bitrate_histPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<lame_global_flags>, ffi.Pointer<ffi.Int>)
    >
  >('lame_bitrate_hist');
  late final _lame_bitrate_hist =
      _lame_bitrate_histPtr
          .asFunction<
            void Function(ffi.Pointer<lame_global_flags>, ffi.Pointer<ffi.Int>)
          >();

  void lame_bitrate_kbps(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Int> bitrate_kbps,
  ) {
    return _lame_bitrate_kbps(gfp, bitrate_kbps);
  }

  late final _lame_bitrate_kbpsPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<lame_global_flags>, ffi.Pointer<ffi.Int>)
    >
  >('lame_bitrate_kbps');
  late final _lame_bitrate_kbps =
      _lame_bitrate_kbpsPtr
          .asFunction<
            void Function(ffi.Pointer<lame_global_flags>, ffi.Pointer<ffi.Int>)
          >();

  void lame_stereo_mode_hist(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Int> stereo_mode_count,
  ) {
    return _lame_stereo_mode_hist(gfp, stereo_mode_count);
  }

  late final _lame_stereo_mode_histPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<lame_global_flags>, ffi.Pointer<ffi.Int>)
    >
  >('lame_stereo_mode_hist');
  late final _lame_stereo_mode_hist =
      _lame_stereo_mode_histPtr
          .asFunction<
            void Function(ffi.Pointer<lame_global_flags>, ffi.Pointer<ffi.Int>)
          >();

  void lame_bitrate_stereo_mode_hist(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Pointer<ffi.Int>> bitrate_stmode_count,
  ) {
    return _lame_bitrate_stereo_mode_hist(gfp, bitrate_stmode_count);
  }

  late final _lame_bitrate_stereo_mode_histPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.Pointer<ffi.Int>>,
      )
    >
  >('lame_bitrate_stereo_mode_hist');
  late final _lame_bitrate_stereo_mode_hist =
      _lame_bitrate_stereo_mode_histPtr
          .asFunction<
            void Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>,
            )
          >();

  void lame_block_type_hist(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Int> btype_count,
  ) {
    return _lame_block_type_hist(gfp, btype_count);
  }

  late final _lame_block_type_histPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<lame_global_flags>, ffi.Pointer<ffi.Int>)
    >
  >('lame_block_type_hist');
  late final _lame_block_type_hist =
      _lame_block_type_histPtr
          .asFunction<
            void Function(ffi.Pointer<lame_global_flags>, ffi.Pointer<ffi.Int>)
          >();

  void lame_bitrate_block_type_hist(
    ffi.Pointer<lame_global_flags> gfp,
    ffi.Pointer<ffi.Pointer<ffi.Int>> bitrate_btype_count,
  ) {
    return _lame_bitrate_block_type_hist(gfp, bitrate_btype_count);
  }

  late final _lame_bitrate_block_type_histPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.Pointer<ffi.Int>>,
      )
    >
  >('lame_bitrate_block_type_hist');
  late final _lame_bitrate_block_type_hist =
      _lame_bitrate_block_type_histPtr
          .asFunction<
            void Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.Pointer<ffi.Int>>,
            )
          >();

  /// OPTIONAL:
  /// lame_mp3_tags_fid will rewrite a Xing VBR tag to the mp3 file with file
  /// pointer fid.  These calls perform forward and backwards seeks, so make
  /// sure fid is a real file.  Make sure lame_encode_flush has been called,
  /// and all mp3 data has been written to the file before calling this
  /// function.
  /// NOTE:
  /// if VBR  tags are turned off by the user, or turned off by LAME because
  /// the output is not a regular file, this call does nothing
  /// NOTE:
  /// LAME wants to read from the file to skip an optional ID3v2 tag, so
  /// make sure you opened the file for writing and reading.
  /// NOTE:
  /// You can call lame_get_lametag_frame instead, if you want to insert
  /// the lametag yourself.
  void lame_mp3_tags_fid(
    ffi.Pointer<lame_global_flags> arg0,
    ffi.Pointer<FILE> fid,
  ) {
    return _lame_mp3_tags_fid(arg0, fid);
  }

  late final _lame_mp3_tags_fidPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<lame_global_flags>, ffi.Pointer<FILE>)
    >
  >('lame_mp3_tags_fid');
  late final _lame_mp3_tags_fid =
      _lame_mp3_tags_fidPtr
          .asFunction<
            void Function(ffi.Pointer<lame_global_flags>, ffi.Pointer<FILE>)
          >();

  /// OPTIONAL:
  /// lame_get_lametag_frame copies the final LAME-tag into 'buffer'.
  /// The function returns the number of bytes copied into buffer, or
  /// the required buffer size, if the provided buffer is too small.
  /// Function failed, if the return value is larger than 'size'!
  /// Make sure lame_encode flush has been called before calling this function.
  /// NOTE:
  /// if VBR  tags are turned off by the user, or turned off by LAME,
  /// this call does nothing and returns 0.
  /// NOTE:
  /// LAME inserted an empty frame in the beginning of mp3 audio data,
  /// which you have to replace by the final LAME-tag frame after encoding.
  /// In case there is no ID3v2 tag, usually this frame will be the very first
  /// data in your mp3 file. If you put some other leading data into your
  /// file, you'll have to do some bookkeeping about where to write this buffer.
  int lame_get_lametag_frame(
    ffi.Pointer<lame_global_flags> arg0,
    ffi.Pointer<ffi.UnsignedChar> buffer,
    int size,
  ) {
    return _lame_get_lametag_frame(arg0, buffer, size);
  }

  late final _lame_get_lametag_framePtr = _lookup<
    ffi.NativeFunction<
      ffi.Size Function(
        ffi.Pointer<lame_global_flags>,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Size,
      )
    >
  >('lame_get_lametag_frame');
  late final _lame_get_lametag_frame =
      _lame_get_lametag_framePtr
          .asFunction<
            int Function(
              ffi.Pointer<lame_global_flags>,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
            )
          >();

  /// REQUIRED:
  /// final call to free all remaining buffers
  int lame_close(ffi.Pointer<lame_global_flags> arg0) {
    return _lame_close(arg0);
  }

  late final _lame_closePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_close');
  late final _lame_close =
      _lame_closePtr.asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// required call to initialize decoder
  hip_t hip_decode_init() {
    return _hip_decode_init();
  }

  late final _hip_decode_initPtr =
      _lookup<ffi.NativeFunction<hip_t Function()>>('hip_decode_init');
  late final _hip_decode_init =
      _hip_decode_initPtr.asFunction<hip_t Function()>();

  /// cleanup call to exit decoder
  int hip_decode_exit(hip_t gfp) {
    return _hip_decode_exit(gfp);
  }

  late final _hip_decode_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(hip_t)>>('hip_decode_exit');
  late final _hip_decode_exit =
      _hip_decode_exitPtr.asFunction<int Function(hip_t)>();

  /// HIP reporting functions
  void hip_set_errorf(hip_t gfp, lame_report_function f) {
    return _hip_set_errorf(gfp, f);
  }

  late final _hip_set_errorfPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(hip_t, lame_report_function)>
  >('hip_set_errorf');
  late final _hip_set_errorf =
      _hip_set_errorfPtr
          .asFunction<void Function(hip_t, lame_report_function)>();

  void hip_set_debugf(hip_t gfp, lame_report_function f) {
    return _hip_set_debugf(gfp, f);
  }

  late final _hip_set_debugfPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(hip_t, lame_report_function)>
  >('hip_set_debugf');
  late final _hip_set_debugf =
      _hip_set_debugfPtr
          .asFunction<void Function(hip_t, lame_report_function)>();

  void hip_set_msgf(hip_t gfp, lame_report_function f) {
    return _hip_set_msgf(gfp, f);
  }

  late final _hip_set_msgfPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(hip_t, lame_report_function)>
  >('hip_set_msgf');
  late final _hip_set_msgf =
      _hip_set_msgfPtr.asFunction<void Function(hip_t, lame_report_function)>();

  /// input 1 mp3 frame, output (maybe) pcm data.
  ///
  /// nout = hip_decode(hip, mp3buf,len,pcm_l,pcm_r);
  ///
  /// input:
  /// len          :  number of bytes of mp3 data in mp3buf
  /// mp3buf[len]  :  mp3 data to be decoded
  ///
  /// output:
  /// nout:  -1    : decoding error
  /// 0    : need more data before we can complete the decode
  /// >0    : returned 'nout' samples worth of data in pcm_l,pcm_r
  /// pcm_l[nout]  : left channel data
  /// pcm_r[nout]  : right channel data
  int hip_decode(
    hip_t gfp,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int len,
    ffi.Pointer<ffi.Short> pcm_l,
    ffi.Pointer<ffi.Short> pcm_r,
  ) {
    return _hip_decode(gfp, mp3buf, len, pcm_l, pcm_r);
  }

  late final _hip_decodePtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        hip_t,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Size,
        ffi.Pointer<ffi.Short>,
        ffi.Pointer<ffi.Short>,
      )
    >
  >('hip_decode');
  late final _hip_decode =
      _hip_decodePtr
          .asFunction<
            int Function(
              hip_t,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<ffi.Short>,
              ffi.Pointer<ffi.Short>,
            )
          >();

  /// same as hip_decode, and also returns mp3 header data
  int hip_decode_headers(
    hip_t gfp,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int len,
    ffi.Pointer<ffi.Short> pcm_l,
    ffi.Pointer<ffi.Short> pcm_r,
    ffi.Pointer<mp3data_struct> mp3data,
  ) {
    return _hip_decode_headers(gfp, mp3buf, len, pcm_l, pcm_r, mp3data);
  }

  late final _hip_decode_headersPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        hip_t,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Size,
        ffi.Pointer<ffi.Short>,
        ffi.Pointer<ffi.Short>,
        ffi.Pointer<mp3data_struct>,
      )
    >
  >('hip_decode_headers');
  late final _hip_decode_headers =
      _hip_decode_headersPtr
          .asFunction<
            int Function(
              hip_t,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<ffi.Short>,
              ffi.Pointer<ffi.Short>,
              ffi.Pointer<mp3data_struct>,
            )
          >();

  /// same as hip_decode, but returns at most one frame
  int hip_decode1(
    hip_t gfp,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int len,
    ffi.Pointer<ffi.Short> pcm_l,
    ffi.Pointer<ffi.Short> pcm_r,
  ) {
    return _hip_decode1(gfp, mp3buf, len, pcm_l, pcm_r);
  }

  late final _hip_decode1Ptr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        hip_t,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Size,
        ffi.Pointer<ffi.Short>,
        ffi.Pointer<ffi.Short>,
      )
    >
  >('hip_decode1');
  late final _hip_decode1 =
      _hip_decode1Ptr
          .asFunction<
            int Function(
              hip_t,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<ffi.Short>,
              ffi.Pointer<ffi.Short>,
            )
          >();

  /// same as hip_decode1, but returns at most one frame and mp3 header data
  int hip_decode1_headers(
    hip_t gfp,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int len,
    ffi.Pointer<ffi.Short> pcm_l,
    ffi.Pointer<ffi.Short> pcm_r,
    ffi.Pointer<mp3data_struct> mp3data,
  ) {
    return _hip_decode1_headers(gfp, mp3buf, len, pcm_l, pcm_r, mp3data);
  }

  late final _hip_decode1_headersPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        hip_t,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Size,
        ffi.Pointer<ffi.Short>,
        ffi.Pointer<ffi.Short>,
        ffi.Pointer<mp3data_struct>,
      )
    >
  >('hip_decode1_headers');
  late final _hip_decode1_headers =
      _hip_decode1_headersPtr
          .asFunction<
            int Function(
              hip_t,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<ffi.Short>,
              ffi.Pointer<ffi.Short>,
              ffi.Pointer<mp3data_struct>,
            )
          >();

  /// same as hip_decode1_headers, but also returns enc_delay and enc_padding
  /// from VBR Info tag, (-1 if no info tag was found)
  int hip_decode1_headersB(
    hip_t gfp,
    ffi.Pointer<ffi.UnsignedChar> mp3buf,
    int len,
    ffi.Pointer<ffi.Short> pcm_l,
    ffi.Pointer<ffi.Short> pcm_r,
    ffi.Pointer<mp3data_struct> mp3data,
    ffi.Pointer<ffi.Int> enc_delay,
    ffi.Pointer<ffi.Int> enc_padding,
  ) {
    return _hip_decode1_headersB(
      gfp,
      mp3buf,
      len,
      pcm_l,
      pcm_r,
      mp3data,
      enc_delay,
      enc_padding,
    );
  }

  late final _hip_decode1_headersBPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        hip_t,
        ffi.Pointer<ffi.UnsignedChar>,
        ffi.Size,
        ffi.Pointer<ffi.Short>,
        ffi.Pointer<ffi.Short>,
        ffi.Pointer<mp3data_struct>,
        ffi.Pointer<ffi.Int>,
        ffi.Pointer<ffi.Int>,
      )
    >
  >('hip_decode1_headersB');
  late final _hip_decode1_headersB =
      _hip_decode1_headersBPtr
          .asFunction<
            int Function(
              hip_t,
              ffi.Pointer<ffi.UnsignedChar>,
              int,
              ffi.Pointer<ffi.Short>,
              ffi.Pointer<ffi.Short>,
              ffi.Pointer<mp3data_struct>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
            )
          >();

  /// utility to obtain alphabetically sorted list of genre names with numbers
  void id3tag_genre_list(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)
      >
    >
    handler,
    ffi.Pointer<ffi.Void> cookie,
  ) {
    return _id3tag_genre_list(handler, cookie);
  }

  late final _id3tag_genre_listPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(
        ffi.Pointer<
          ffi.NativeFunction<
            ffi.Void Function(
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
            )
          >
        >,
        ffi.Pointer<ffi.Void>,
      )
    >
  >('id3tag_genre_list');
  late final _id3tag_genre_list =
      _id3tag_genre_listPtr
          .asFunction<
            void Function(
              ffi.Pointer<
                ffi.NativeFunction<
                  ffi.Void Function(
                    ffi.Int,
                    ffi.Pointer<ffi.Char>,
                    ffi.Pointer<ffi.Void>,
                  )
                >
              >,
              ffi.Pointer<ffi.Void>,
            )
          >();

  void id3tag_init(lame_t gfp) {
    return _id3tag_init(gfp);
  }

  late final _id3tag_initPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lame_t)>>('id3tag_init');
  late final _id3tag_init = _id3tag_initPtr.asFunction<void Function(lame_t)>();

  /// force addition of version 2 tag
  void id3tag_add_v2(lame_t gfp) {
    return _id3tag_add_v2(gfp);
  }

  late final _id3tag_add_v2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lame_t)>>('id3tag_add_v2');
  late final _id3tag_add_v2 =
      _id3tag_add_v2Ptr.asFunction<void Function(lame_t)>();

  /// add only a version 1 tag
  void id3tag_v1_only(lame_t gfp) {
    return _id3tag_v1_only(gfp);
  }

  late final _id3tag_v1_onlyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lame_t)>>('id3tag_v1_only');
  late final _id3tag_v1_only =
      _id3tag_v1_onlyPtr.asFunction<void Function(lame_t)>();

  /// add only a version 2 tag
  void id3tag_v2_only(lame_t gfp) {
    return _id3tag_v2_only(gfp);
  }

  late final _id3tag_v2_onlyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lame_t)>>('id3tag_v2_only');
  late final _id3tag_v2_only =
      _id3tag_v2_onlyPtr.asFunction<void Function(lame_t)>();

  /// pad version 1 tag with spaces instead of nulls
  void id3tag_space_v1(lame_t gfp) {
    return _id3tag_space_v1(gfp);
  }

  late final _id3tag_space_v1Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lame_t)>>('id3tag_space_v1');
  late final _id3tag_space_v1 =
      _id3tag_space_v1Ptr.asFunction<void Function(lame_t)>();

  /// pad version 2 tag with extra 128 bytes
  void id3tag_pad_v2(lame_t gfp) {
    return _id3tag_pad_v2(gfp);
  }

  late final _id3tag_pad_v2Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lame_t)>>('id3tag_pad_v2');
  late final _id3tag_pad_v2 =
      _id3tag_pad_v2Ptr.asFunction<void Function(lame_t)>();

  /// pad version 2 tag with extra n bytes
  void id3tag_set_pad(lame_t gfp, int n) {
    return _id3tag_set_pad(gfp, n);
  }

  late final _id3tag_set_padPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(lame_t, ffi.Size)>>(
        'id3tag_set_pad',
      );
  late final _id3tag_set_pad =
      _id3tag_set_padPtr.asFunction<void Function(lame_t, int)>();

  void id3tag_set_title(lame_t gfp, ffi.Pointer<ffi.Char> title) {
    return _id3tag_set_title(gfp, title);
  }

  late final _id3tag_set_titlePtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(lame_t, ffi.Pointer<ffi.Char>)>
  >('id3tag_set_title');
  late final _id3tag_set_title =
      _id3tag_set_titlePtr
          .asFunction<void Function(lame_t, ffi.Pointer<ffi.Char>)>();

  void id3tag_set_artist(lame_t gfp, ffi.Pointer<ffi.Char> artist) {
    return _id3tag_set_artist(gfp, artist);
  }

  late final _id3tag_set_artistPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(lame_t, ffi.Pointer<ffi.Char>)>
  >('id3tag_set_artist');
  late final _id3tag_set_artist =
      _id3tag_set_artistPtr
          .asFunction<void Function(lame_t, ffi.Pointer<ffi.Char>)>();

  void id3tag_set_album(lame_t gfp, ffi.Pointer<ffi.Char> album) {
    return _id3tag_set_album(gfp, album);
  }

  late final _id3tag_set_albumPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(lame_t, ffi.Pointer<ffi.Char>)>
  >('id3tag_set_album');
  late final _id3tag_set_album =
      _id3tag_set_albumPtr
          .asFunction<void Function(lame_t, ffi.Pointer<ffi.Char>)>();

  void id3tag_set_year(lame_t gfp, ffi.Pointer<ffi.Char> year) {
    return _id3tag_set_year(gfp, year);
  }

  late final _id3tag_set_yearPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(lame_t, ffi.Pointer<ffi.Char>)>
  >('id3tag_set_year');
  late final _id3tag_set_year =
      _id3tag_set_yearPtr
          .asFunction<void Function(lame_t, ffi.Pointer<ffi.Char>)>();

  void id3tag_set_comment(lame_t gfp, ffi.Pointer<ffi.Char> comment) {
    return _id3tag_set_comment(gfp, comment);
  }

  late final _id3tag_set_commentPtr = _lookup<
    ffi.NativeFunction<ffi.Void Function(lame_t, ffi.Pointer<ffi.Char>)>
  >('id3tag_set_comment');
  late final _id3tag_set_comment =
      _id3tag_set_commentPtr
          .asFunction<void Function(lame_t, ffi.Pointer<ffi.Char>)>();

  /// return -1 result if track number is out of ID3v1 range
  /// and ignored for ID3v1
  int id3tag_set_track(lame_t gfp, ffi.Pointer<ffi.Char> track) {
    return _id3tag_set_track(gfp, track);
  }

  late final _id3tag_set_trackPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(lame_t, ffi.Pointer<ffi.Char>)>
  >('id3tag_set_track');
  late final _id3tag_set_track =
      _id3tag_set_trackPtr
          .asFunction<int Function(lame_t, ffi.Pointer<ffi.Char>)>();

  /// return non-zero result if genre name or number is invalid
  /// result 0: OK
  /// result -1: genre number out of range
  /// result -2: no valid ID3v1 genre name, mapped to ID3v1 'Other'
  /// but taken as-is for ID3v2 genre tag
  int id3tag_set_genre(lame_t gfp, ffi.Pointer<ffi.Char> genre) {
    return _id3tag_set_genre(gfp, genre);
  }

  late final _id3tag_set_genrePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(lame_t, ffi.Pointer<ffi.Char>)>
  >('id3tag_set_genre');
  late final _id3tag_set_genre =
      _id3tag_set_genrePtr
          .asFunction<int Function(lame_t, ffi.Pointer<ffi.Char>)>();

  /// return non-zero result if field name is invalid
  int id3tag_set_fieldvalue(lame_t gfp, ffi.Pointer<ffi.Char> fieldvalue) {
    return _id3tag_set_fieldvalue(gfp, fieldvalue);
  }

  late final _id3tag_set_fieldvaluePtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(lame_t, ffi.Pointer<ffi.Char>)>
  >('id3tag_set_fieldvalue');
  late final _id3tag_set_fieldvalue =
      _id3tag_set_fieldvaluePtr
          .asFunction<int Function(lame_t, ffi.Pointer<ffi.Char>)>();

  /// return non-zero result if image type is invalid
  int id3tag_set_albumart(lame_t gfp, ffi.Pointer<ffi.Char> image, int size) {
    return _id3tag_set_albumart(gfp, image, size);
  }

  late final _id3tag_set_albumartPtr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(lame_t, ffi.Pointer<ffi.Char>, ffi.Size)
    >
  >('id3tag_set_albumart');
  late final _id3tag_set_albumart =
      _id3tag_set_albumartPtr
          .asFunction<int Function(lame_t, ffi.Pointer<ffi.Char>, int)>();

  /// lame_get_id3v1_tag copies ID3v1 tag into buffer.
  /// Function returns number of bytes copied into buffer, or number
  /// of bytes rquired if buffer 'size' is too small.
  /// Function fails, if returned value is larger than 'size'.
  /// NOTE:
  /// This functions does nothing, if user/LAME disabled ID3v1 tag.
  int lame_get_id3v1_tag(
    lame_t gfp,
    ffi.Pointer<ffi.UnsignedChar> buffer,
    int size,
  ) {
    return _lame_get_id3v1_tag(gfp, buffer, size);
  }

  late final _lame_get_id3v1_tagPtr = _lookup<
    ffi.NativeFunction<
      ffi.Size Function(lame_t, ffi.Pointer<ffi.UnsignedChar>, ffi.Size)
    >
  >('lame_get_id3v1_tag');
  late final _lame_get_id3v1_tag =
      _lame_get_id3v1_tagPtr
          .asFunction<
            int Function(lame_t, ffi.Pointer<ffi.UnsignedChar>, int)
          >();

  /// lame_get_id3v2_tag copies ID3v2 tag into buffer.
  /// Function returns number of bytes copied into buffer, or number
  /// of bytes rquired if buffer 'size' is too small.
  /// Function fails, if returned value is larger than 'size'.
  /// NOTE:
  /// This functions does nothing, if user/LAME disabled ID3v2 tag.
  int lame_get_id3v2_tag(
    lame_t gfp,
    ffi.Pointer<ffi.UnsignedChar> buffer,
    int size,
  ) {
    return _lame_get_id3v2_tag(gfp, buffer, size);
  }

  late final _lame_get_id3v2_tagPtr = _lookup<
    ffi.NativeFunction<
      ffi.Size Function(lame_t, ffi.Pointer<ffi.UnsignedChar>, ffi.Size)
    >
  >('lame_get_id3v2_tag');
  late final _lame_get_id3v2_tag =
      _lame_get_id3v2_tagPtr
          .asFunction<
            int Function(lame_t, ffi.Pointer<ffi.UnsignedChar>, int)
          >();

  /// normaly lame_init_param writes ID3v2 tags into the audio stream
  /// Call lame_set_write_id3tag_automatic(gfp, 0) before lame_init_param
  /// to turn off this behaviour and get ID3v2 tag with above function
  /// write it yourself into your file.
  void lame_set_write_id3tag_automatic(
    ffi.Pointer<lame_global_flags> gfp,
    int arg1,
  ) {
    return _lame_set_write_id3tag_automatic(gfp, arg1);
  }

  late final _lame_set_write_id3tag_automaticPtr = _lookup<
    ffi.NativeFunction<
      ffi.Void Function(ffi.Pointer<lame_global_flags>, ffi.Int)
    >
  >('lame_set_write_id3tag_automatic');
  late final _lame_set_write_id3tag_automatic =
      _lame_set_write_id3tag_automaticPtr
          .asFunction<void Function(ffi.Pointer<lame_global_flags>, int)>();

  int lame_get_write_id3tag_automatic(ffi.Pointer<lame_global_flags> gfp) {
    return _lame_get_write_id3tag_automatic(gfp);
  }

  late final _lame_get_write_id3tag_automaticPtr = _lookup<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<lame_global_flags>)>
  >('lame_get_write_id3tag_automatic');
  late final _lame_get_write_id3tag_automatic =
      _lame_get_write_id3tag_automaticPtr
          .asFunction<int Function(ffi.Pointer<lame_global_flags>)>();

  /// experimental
  int id3tag_set_textinfo_latin1(
    lame_t gfp,
    ffi.Pointer<ffi.Char> id,
    ffi.Pointer<ffi.Char> text,
  ) {
    return _id3tag_set_textinfo_latin1(gfp, id, text);
  }

  late final _id3tag_set_textinfo_latin1Ptr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(lame_t, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)
    >
  >('id3tag_set_textinfo_latin1');
  late final _id3tag_set_textinfo_latin1 =
      _id3tag_set_textinfo_latin1Ptr
          .asFunction<
            int Function(lame_t, ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)
          >();

  /// experimental
  int id3tag_set_comment_latin1(
    lame_t gfp,
    ffi.Pointer<ffi.Char> lang,
    ffi.Pointer<ffi.Char> desc,
    ffi.Pointer<ffi.Char> text,
  ) {
    return _id3tag_set_comment_latin1(gfp, lang, desc, text);
  }

  late final _id3tag_set_comment_latin1Ptr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        lame_t,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>,
      )
    >
  >('id3tag_set_comment_latin1');
  late final _id3tag_set_comment_latin1 =
      _id3tag_set_comment_latin1Ptr
          .asFunction<
            int Function(
              lame_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
            )
          >();

  /// experimental
  int id3tag_set_fieldvalue_utf16(
    lame_t gfp,
    ffi.Pointer<ffi.UnsignedShort> fieldvalue,
  ) {
    return _id3tag_set_fieldvalue_utf16(gfp, fieldvalue);
  }

  late final _id3tag_set_fieldvalue_utf16Ptr = _lookup<
    ffi.NativeFunction<ffi.Int Function(lame_t, ffi.Pointer<ffi.UnsignedShort>)>
  >('id3tag_set_fieldvalue_utf16');
  late final _id3tag_set_fieldvalue_utf16 =
      _id3tag_set_fieldvalue_utf16Ptr
          .asFunction<int Function(lame_t, ffi.Pointer<ffi.UnsignedShort>)>();

  /// experimental
  int id3tag_set_textinfo_utf16(
    lame_t gfp,
    ffi.Pointer<ffi.Char> id,
    ffi.Pointer<ffi.UnsignedShort> text,
  ) {
    return _id3tag_set_textinfo_utf16(gfp, id, text);
  }

  late final _id3tag_set_textinfo_utf16Ptr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        lame_t,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.UnsignedShort>,
      )
    >
  >('id3tag_set_textinfo_utf16');
  late final _id3tag_set_textinfo_utf16 =
      _id3tag_set_textinfo_utf16Ptr
          .asFunction<
            int Function(
              lame_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedShort>,
            )
          >();

  /// experimental
  int id3tag_set_comment_utf16(
    lame_t gfp,
    ffi.Pointer<ffi.Char> lang,
    ffi.Pointer<ffi.UnsignedShort> desc,
    ffi.Pointer<ffi.UnsignedShort> text,
  ) {
    return _id3tag_set_comment_utf16(gfp, lang, desc, text);
  }

  late final _id3tag_set_comment_utf16Ptr = _lookup<
    ffi.NativeFunction<
      ffi.Int Function(
        lame_t,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.UnsignedShort>,
        ffi.Pointer<ffi.UnsignedShort>,
      )
    >
  >('id3tag_set_comment_utf16');
  late final _id3tag_set_comment_utf16 =
      _id3tag_set_comment_utf16Ptr
          .asFunction<
            int Function(
              lame_t,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<ffi.UnsignedShort>,
            )
          >();

  /// list of valid bitrates [kbps] & sample frequencies [Hz].
  /// first index: 0: MPEG-2   values  (sample frequencies 16...24 kHz)
  /// 1: MPEG-1   values  (sample frequencies 32...48 kHz)
  /// 2: MPEG-2.5 values  (sample frequencies  8...12 kHz)
  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int>>> _bitrate_table =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Int>>>('bitrate_table');

  ffi.Pointer<ffi.Pointer<ffi.Int>> get bitrate_table => _bitrate_table.value;

  set bitrate_table(ffi.Pointer<ffi.Pointer<ffi.Int>> value) =>
      _bitrate_table.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int>>> _samplerate_table =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Int>>>('samplerate_table');

  ffi.Pointer<ffi.Pointer<ffi.Int>> get samplerate_table =>
      _samplerate_table.value;

  set samplerate_table(ffi.Pointer<ffi.Pointer<ffi.Int>> value) =>
      _samplerate_table.value = value;

  /// access functions for use in DLL, global vars are not exported
  int lame_get_bitrate(int mpeg_version, int table_index) {
    return _lame_get_bitrate(mpeg_version, table_index);
  }

  late final _lame_get_bitratePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
        'lame_get_bitrate',
      );
  late final _lame_get_bitrate =
      _lame_get_bitratePtr.asFunction<int Function(int, int)>();

  int lame_get_samplerate(int mpeg_version, int table_index) {
    return _lame_get_samplerate(mpeg_version, table_index);
  }

  late final _lame_get_sampleratePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
        'lame_get_samplerate',
      );
  late final _lame_get_samplerate =
      _lame_get_sampleratePtr.asFunction<int Function(int, int)>();
}

enum vbr_mode_e {
  vbr_off(0),

  /// obsolete, same as vbr_mtrh
  vbr_mt(1),
  vbr_rh(2),
  vbr_abr(3),
  vbr_mtrh(4),

  /// Don't use this! It's used for sanity checks.
  vbr_max_indicator(5);

  /// change this to change the default VBR mode of LAME
  static const vbr_default = vbr_mtrh;

  final int value;
  const vbr_mode_e(this.value);

  static vbr_mode_e fromValue(int value) => switch (value) {
    0 => vbr_off,
    1 => vbr_mt,
    2 => vbr_rh,
    3 => vbr_abr,
    4 => vbr_mtrh,
    5 => vbr_max_indicator,
    _ => throw ArgumentError("Unknown value for vbr_mode_e: $value"),
  };

  @override
  String toString() {
    if (this == vbr_mtrh) return "vbr_mode_e.vbr_mtrh, vbr_mode_e.vbr_default";
    return super.toString();
  }
}

/// MPEG modes
enum MPEG_mode_e {
  STEREO(0),
  JOINT_STEREO(1),

  /// LAME doesn't supports this!
  DUAL_CHANNEL(2),
  MONO(3),
  NOT_SET(4),

  /// Don't use this! It's used for sanity checks.
  MAX_INDICATOR(5);

  final int value;
  const MPEG_mode_e(this.value);

  static MPEG_mode_e fromValue(int value) => switch (value) {
    0 => STEREO,
    1 => JOINT_STEREO,
    2 => DUAL_CHANNEL,
    3 => MONO,
    4 => NOT_SET,
    5 => MAX_INDICATOR,
    _ => throw ArgumentError("Unknown value for MPEG_mode_e: $value"),
  };
}

/// Padding types
enum Padding_type_e {
  PAD_NO(0),
  PAD_ALL(1),
  PAD_ADJUST(2),

  /// Don't use this! It's used for sanity checks.
  PAD_MAX_INDICATOR(3);

  final int value;
  const Padding_type_e(this.value);

  static Padding_type_e fromValue(int value) => switch (value) {
    0 => PAD_NO,
    1 => PAD_ALL,
    2 => PAD_ADJUST,
    3 => PAD_MAX_INDICATOR,
    _ => throw ArgumentError("Unknown value for Padding_type_e: $value"),
  };
}

/// presets
enum preset_mode_e {
  /// values from 8 to 320 should be reserved for abr bitrates*/
  /// /*for abr I'd suggest to directly use the targeted bitrate as a value
  ABR_8(8),
  ABR_320(320),

  /// Vx to match Lame and VBR_xx to match FhG
  V9(410),
  V8(420),
  V7(430),
  V6(440),
  V5(450),
  V4(460),
  V3(470),
  V2(480),
  V1(490),
  V0(500),

  /// still there for compatibility
  R3MIX(1000),
  STANDARD(1001),
  EXTREME(1002),
  INSANE(1003),
  STANDARD_FAST(1004),
  EXTREME_FAST(1005),
  MEDIUM(1006),
  MEDIUM_FAST(1007);

  static const VBR_10 = V9;
  static const VBR_20 = V8;
  static const VBR_30 = V7;
  static const VBR_40 = V6;
  static const VBR_50 = V5;
  static const VBR_60 = V4;
  static const VBR_70 = V3;
  static const VBR_80 = V2;
  static const VBR_90 = V1;
  static const VBR_100 = V0;

  final int value;
  const preset_mode_e(this.value);

  static preset_mode_e fromValue(int value) => switch (value) {
    8 => ABR_8,
    320 => ABR_320,
    410 => V9,
    420 => V8,
    430 => V7,
    440 => V6,
    450 => V5,
    460 => V4,
    470 => V3,
    480 => V2,
    490 => V1,
    500 => V0,
    1000 => R3MIX,
    1001 => STANDARD,
    1002 => EXTREME,
    1003 => INSANE,
    1004 => STANDARD_FAST,
    1005 => EXTREME_FAST,
    1006 => MEDIUM,
    1007 => MEDIUM_FAST,
    _ => throw ArgumentError("Unknown value for preset_mode_e: $value"),
  };

  @override
  String toString() {
    if (this == V9) return "preset_mode_e.V9, preset_mode_e.VBR_10";
    if (this == V8) return "preset_mode_e.V8, preset_mode_e.VBR_20";
    if (this == V7) return "preset_mode_e.V7, preset_mode_e.VBR_30";
    if (this == V6) return "preset_mode_e.V6, preset_mode_e.VBR_40";
    if (this == V5) return "preset_mode_e.V5, preset_mode_e.VBR_50";
    if (this == V4) return "preset_mode_e.V4, preset_mode_e.VBR_60";
    if (this == V3) return "preset_mode_e.V3, preset_mode_e.VBR_70";
    if (this == V2) return "preset_mode_e.V2, preset_mode_e.VBR_80";
    if (this == V1) return "preset_mode_e.V1, preset_mode_e.VBR_90";
    if (this == V0) return "preset_mode_e.V0, preset_mode_e.VBR_100";
    return super.toString();
  }
}

/// asm optimizations
enum asm_optimizations_e {
  MMX(1),
  AMD_3DNOW(2),
  SSE(3);

  final int value;
  const asm_optimizations_e(this.value);

  static asm_optimizations_e fromValue(int value) => switch (value) {
    1 => MMX,
    2 => AMD_3DNOW,
    3 => SSE,
    _ => throw ArgumentError("Unknown value for asm_optimizations_e: $value"),
  };
}

/// psychoacoustic model
enum Psy_model_e {
  PSY_GPSYCHO(1),
  PSY_NSPSYTUNE(2);

  final int value;
  const Psy_model_e(this.value);

  static Psy_model_e fromValue(int value) => switch (value) {
    1 => PSY_GPSYCHO,
    2 => PSY_NSPSYTUNE,
    _ => throw ArgumentError("Unknown value for Psy_model_e: $value"),
  };
}

/// buffer considerations
enum buffer_constraint_e {
  MDB_DEFAULT(0),
  MDB_STRICT_ISO(1),
  MDB_MAXIMUM(2);

  final int value;
  const buffer_constraint_e(this.value);

  static buffer_constraint_e fromValue(int value) => switch (value) {
    0 => MDB_DEFAULT,
    1 => MDB_STRICT_ISO,
    2 => MDB_MAXIMUM,
    _ => throw ArgumentError("Unknown value for buffer_constraint_e: $value"),
  };
}

final class lame_global_struct extends ffi.Opaque {}

typedef lame_global_flags = lame_global_struct;
typedef lame_report_function =
    ffi.Pointer<ffi.NativeFunction<lame_report_functionFunction>>;
typedef lame_report_functionFunction =
    ffi.Void Function(ffi.Pointer<ffi.Char> format, va_list ap);
typedef Dartlame_report_functionFunction =
    void Function(ffi.Pointer<ffi.Char> format, va_list ap);
typedef va_list = __darwin_va_list;
typedef __darwin_va_list = __builtin_va_list;
typedef __builtin_va_list = ffi.Pointer<ffi.Char>;
typedef lame_t = ffi.Pointer<lame_global_flags>;

/// OPTIONAL:
/// get the version numbers in numerical form.
final class lame_version_t extends ffi.Struct {
  /// generic LAME version
  @ffi.Int()
  external int major;

  @ffi.Int()
  external int minor;

  /// 0 if not an alpha version
  @ffi.Int()
  external int alpha;

  /// 0 if not a beta version
  @ffi.Int()
  external int beta;

  /// version of the psy model
  @ffi.Int()
  external int psy_major;

  @ffi.Int()
  external int psy_minor;

  /// 0 if not an alpha version
  @ffi.Int()
  external int psy_alpha;

  /// 0 if not a beta version
  @ffi.Int()
  external int psy_beta;

  /// Don't make assumptions about the contents!
  external ffi.Pointer<ffi.Char> features;
}

/// stdio state variables.
///
/// The following always hold:
///
/// if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
/// _lbfsize is -_bf._size, else _lbfsize is 0
/// if _flags&__SRD, _w is 0
/// if _flags&__SWR, _r is 0
///
/// This ensures that the getc and putc macros (or inline functions) never
/// try to write or read from a file that is in `read' or `write' mode.
/// (Moreover, they can, and do, automatically switch from read mode to
/// write mode, and back, on "r+" and "w+" files.)
///
/// _lbfsize is used only to make the inline line-buffered output stream
/// code as compact as possible.
///
/// _ub, _up, and _ur are used when ungetc() pushes back more characters
/// than fit in the current _bf, or when ungetc() pushes back a character
/// that does not match the previous one in _bf.  When this happens,
/// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
/// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
///
/// NB: see WARNING above before changing the layout of this structure!
typedef FILE = __sFILE;

/// stdio state variables.
///
/// The following always hold:
///
/// if (_flags&(__SLBF|__SWR)) == (__SLBF|__SWR),
/// _lbfsize is -_bf._size, else _lbfsize is 0
/// if _flags&__SRD, _w is 0
/// if _flags&__SWR, _r is 0
///
/// This ensures that the getc and putc macros (or inline functions) never
/// try to write or read from a file that is in `read' or `write' mode.
/// (Moreover, they can, and do, automatically switch from read mode to
/// write mode, and back, on "r+" and "w+" files.)
///
/// _lbfsize is used only to make the inline line-buffered output stream
/// code as compact as possible.
///
/// _ub, _up, and _ur are used when ungetc() pushes back more characters
/// than fit in the current _bf, or when ungetc() pushes back a character
/// that does not match the previous one in _bf.  When this happens,
/// _ub._base becomes non-nil (i.e., a stream has ungetc() data iff
/// _ub._base!=NULL) and _up and _ur save the current values of _p and _r.
///
/// NB: see WARNING above before changing the layout of this structure!
final class __sFILE extends ffi.Struct {
  /// current position in (some) buffer
  external ffi.Pointer<ffi.UnsignedChar> _p;

  /// read space left for getc()
  @ffi.Int()
  external int _r;

  /// write space left for putc()
  @ffi.Int()
  external int _w;

  /// flags, below; this FILE is free if 0
  @ffi.Short()
  external int _flags;

  /// fileno, if Unix descriptor, else -1
  @ffi.Short()
  external int _file;

  /// the buffer (at least 1 byte, if !NULL)
  external __sbuf _bf;

  /// 0 or -_bf._size, for inline putc
  @ffi.Int()
  external int _lbfsize;

  /// cookie passed to io functions
  external ffi.Pointer<ffi.Void> _cookie;

  external ffi.Pointer<
    ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>
  >
  _close;

  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)
    >
  >
  _read;

  external ffi.Pointer<
    ffi.NativeFunction<fpos_t Function(ffi.Pointer<ffi.Void>, fpos_t, ffi.Int)>
  >
  _seek;

  external ffi.Pointer<
    ffi.NativeFunction<
      ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Char>, ffi.Int)
    >
  >
  _write;

  /// ungetc buffer
  external __sbuf _ub;

  /// additions to FILE to not break ABI
  external ffi.Pointer<__sFILEX> _extra;

  /// saved _r when _r is counting ungetc data
  @ffi.Int()
  external int _ur;

  /// guarantee an ungetc() buffer
  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedChar> _ubuf;

  /// guarantee a getc() buffer
  @ffi.Array.multi([1])
  external ffi.Array<ffi.UnsignedChar> _nbuf;

  /// buffer for fgetln()
  external __sbuf _lb;

  /// stat.st_blksize (may be != _bf._size)
  @ffi.Int()
  external int _blksize;

  /// current lseek offset (see WARNING)
  @fpos_t()
  external int _offset;
}

/// stdio buffers
final class __sbuf extends ffi.Struct {
  external ffi.Pointer<ffi.UnsignedChar> _base;

  @ffi.Int()
  external int _size;
}

typedef fpos_t = __darwin_off_t;
typedef __darwin_off_t = __int64_t;
typedef __int64_t = ffi.LongLong;
typedef Dart__int64_t = int;

/// hold a buncha junk that would grow the ABI
final class __sFILEX extends ffi.Opaque {}

/// decoding
///
/// a simple interface to mpglib, part of mpg123, is also included if
/// libmp3lame is compiled with HAVE_MPGLIB
final class hip_global_struct extends ffi.Opaque {}

final class mp3data_struct extends ffi.Struct {
  /// 1 if header was parsed and following data was
  /// computed
  @ffi.Int()
  external int header_parsed;

  /// number of channels
  @ffi.Int()
  external int stereo;

  /// sample rate
  @ffi.Int()
  external int samplerate;

  /// bitrate
  @ffi.Int()
  external int bitrate;

  /// mp3 frame type
  @ffi.Int()
  external int mode;

  /// mp3 frame type
  @ffi.Int()
  external int mode_ext;

  /// number of samples per mp3 frame
  @ffi.Int()
  external int framesize;

  /// number of samples in mp3 file.
  @ffi.UnsignedLong()
  external int nsamp;

  /// total number of frames in mp3 file
  @ffi.Int()
  external int totalframes;

  /// frames decoded counter
  @ffi.Int()
  external int framenum;
}

typedef hip_t = ffi.Pointer<hip_global_flags>;
typedef hip_global_flags = hip_global_struct;

enum lame_errorcodes_t {
  LAME_OKAY(0),
  LAME_GENERICERROR(-1),
  LAME_NOMEM(-10),
  LAME_BADBITRATE(-11),
  LAME_BADSAMPFREQ(-12),
  LAME_INTERNALERROR(-13),
  FRONTEND_READERROR(-80),
  FRONTEND_WRITEERROR(-81),
  FRONTEND_FILETOOLARGE(-82);

  static const LAME_NOERROR = LAME_OKAY;

  final int value;
  const lame_errorcodes_t(this.value);

  static lame_errorcodes_t fromValue(int value) => switch (value) {
    0 => LAME_OKAY,
    -1 => LAME_GENERICERROR,
    -10 => LAME_NOMEM,
    -11 => LAME_BADBITRATE,
    -12 => LAME_BADSAMPFREQ,
    -13 => LAME_INTERNALERROR,
    -80 => FRONTEND_READERROR,
    -81 => FRONTEND_WRITEERROR,
    -82 => FRONTEND_FILETOOLARGE,
    _ => throw ArgumentError("Unknown value for lame_errorcodes_t: $value"),
  };

  @override
  String toString() {
    if (this == LAME_OKAY)
      return "lame_errorcodes_t.LAME_OKAY, lame_errorcodes_t.LAME_NOERROR";
    return super.toString();
  }
}

const int DEPRECATED_OR_OBSOLETE_CODE_REMOVED = 1;

const int LAME_MAXALBUMART = 131072;

const int LAME_MAXMP3BUFFER = 147456;
